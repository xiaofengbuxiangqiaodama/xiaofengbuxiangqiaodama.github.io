---
layout: post
title: 第一次记录-Java内存
date: 2021-10-19
tags: java   
-------------------------------

这是自己写的第一个博客，打算用博客记录一下自己算法学习笔记，第一此就来记录一下Java中的内存笔记




## Java内存详解

###  对象

一个对象所使用的内存量，需要将所有实例变量使用的内存于对象本身的开销（一般是16字节）相加。这些开销包括一个
指向对象的类的引用、垃圾收集信息以及同步信息。
另外，一般内存的使用搜会被填充为8字节（64位计算机的机器字）的倍数。
例如：
[*] 一个Integer对象会使用24字节（16字节对象开销，4字节用于保存它的int值以及4个填充字节）
[*] 一个Date对象需要使用32字节（16字节对象开销，3个int实例变量各需4字节，以及4个填充字节）

对象的引用一般是内存地址，一次会使用8个字节。当我们说明一个引用所占的内存时，我们会单独说明它所指向的对象所占用的内存，
因此这个内存使用总量并没有包含String值所使用的内存


### 链表

**嵌套**的非静态（内部类），例如我们的Node类，就还需要额外的8个字节（用于一个指向外部类的引用）因此，一个Node对象需要
使用40字节（16字节对象开销，指向Item和Node的对象的引用个需8个字节，另外还要8字节的额外开销）因为Integer对象需要使用24
字节，一个含有N个整数的基于链表的栈需要使用（32+64N)字节，包括Strack对象的16字节开销，引用类型实例变量8字节，inr类型实
例变量4字节，4个填充字节，每个元素需要64字节，一个Node对象的40字节和一个Integer对象的24字节。


### 数组

 1.一个原始数据类型的数组一般需要24字节头信息（16字节的对象开销，4字节用于保存长度以及4填充字节）再加上保存所需内存。
例如：
 [*] 一个含有N个int值的数组需要使用（24+4N）字节（会被填充为8的倍数）
 [*] 一个含有N个double值的数组需要使用（24+8N）字节
 2、一个对象数组就是对象的引用的数组，所以我们应该在对象所需的内存之外加上引用所需的内存
 例如：
 [*] 一个含有N个Date对象的数组需要使用24字节（数组开销）加上8N字节(所有引用）加上每个对象的32字节，总共（24+40N）字节
 3.二位数组是一个数组的数组（每一个数组都是一个对象元素）
 例如：
 [*] 一个M*N的double类型的二维数组需要使用24字节（数组的数组的开销）加上8M字节（所有元素数组的引用）加上24	M字节（所有
元素数组的开销）加上8MN字节（M个总长度为N的double类型的数组）总共（8MN+32M+24M)~8MN字节

**当数组元素是对象时计算方法类似，结果相同，用来保存充满指向数组对象的引用数组一号机所有这些对象本身。**


### 字符串对象

Sring的标准实现有4个实例变量：一个指向字符数组的引用（8字节）和三个int值（各4各字节）
[*] 第一个int值描述的是字符数组中的偏移量
[*] 第二个int值是一个计数器（字符串长度）
[*] 第三个int值是一个散列值（它在某些情况下可以节省一些计算，完美现在可以忽略它。
因此每个String对象总共会使用40字节（16字节表示对象，三个int实例变量各需4个字节，加上数组引用的8字节和4个填充字节）。
注：不包含字符数组的内存

### 字符串的值和子字符串

一个长度为N的String对象一般需要使用40字节（String对象本身）加上（24+2N）字节（字符数组），总共（64+2N）字节。
但字符串处理经常会和子字符串打交道，所以Java对字符串的表示希望能够避免复制字符串中的字符。
当你调用substring()方法时，就创建了一个新的String对象(40字节)，但它仍然重用了相同的value[]数组，因此该字符串的子字符串
只会使用40字节的内存。含有原始字符串的字符数组的别名存在于子字符串中，子字符串对象的偏移量和长度域标记了子字符串的位置。
换句话说，一个子字符串所需的额外内存是一个常数，构造一个子字符串所需的时间也是常数，即使字符串和子字符串的长度极大也
是这样。某些简陋的字符串表示方法在创建子字符串时需要复制其中的字符，这将需要线性的时间和空间。确保子字符串的创建所需的
空间(以及时间)和其长度无关是许多基础字符串处理算法的效率的关键所在。字符串的值与子字符串示这些基础机制能够有效帮助
我们估计大量程序对内存的使用情况，但许多复杂的因素仍然会使这个任务变得更加困难。我们已经提到了别名可能产生的潜在影响，
另外，当涉及函数调用时，内存的消耗就变成了一个复杂的动态过程，因为java系统的内存分配机制扮演一个重要的角色，而这套机制
又和java实现有关。

